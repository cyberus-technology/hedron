/*
 * ACPI FADT Parser Test Helpers
 *
 * Copyright (C) 2022 Sebastian Eydam, Cyberus Technology GmbH.
 *
 * This file is part of the Hedron microhypervisor.
 *
 * Hedron is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 * Hedron is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License version 2 for more details.
 */

#pragma once

#include <array>
#include <cstdint>

#include "acpi_gas.hpp"

// This header contains code used to test the FADT parsing:
// - a struct that can be used to easily check the content of the Generic Address Structures the FADT parsing
//   parses from a FADT
// - different FADTs which cover different cases the FADT parsing should be able to handle

// This structure holds desired values of the respective ACPI registers.
struct Gas_values {
    // The Acpi_gas class currently has no constructor and adding one leads to problems with the existing
    // code. Thus this struct is used meanwhile.
    struct Gas_value {
        uint8_t asid{0};
        uint8_t bits{0};
        uint64_t addr{0};

        Gas_value() : asid(0), bits(0), addr(0) {}
        Gas_value(uint8_t asid_, uint8_t bits_, uint64_t addr_) : asid(asid_), bits(bits_), addr(addr_) {}

        bool operator==(const Acpi_gas& acpi_gas) const
        {
            return asid == acpi_gas.asid and bits == acpi_gas.bits and addr == acpi_gas.addr;
        }
    };

    Gas_value pm1a_sts;
    Gas_value pm1a_ena;
    Gas_value pm1b_sts;
    Gas_value pm1b_ena;
    Gas_value pm1a_cnt;
    Gas_value pm1b_cnt;
    Gas_value pm2_cnt;
    Gas_value pm_tmr;
    Gas_value gpe0_sts;
    Gas_value gpe0_ena;
    Gas_value gpe1_sts;
    Gas_value gpe1_ena;
};

using Gas_value = Gas_values::Gas_value;

// The values of the registers encoded into the XPS FADT.
inline const Gas_values xps_gas_values{.pm1a_sts = Gas_value(1, 16, 0x1800),
                                       .pm1a_ena = Gas_value(1, 16, 0x1802),
                                       .pm1b_sts = Gas_value(),
                                       .pm1b_ena = Gas_value(),
                                       .pm1a_cnt = Gas_value(1, 16, 0x1804),
                                       .pm1b_cnt = Gas_value(),
                                       .pm2_cnt = Gas_value(1, 8, 0x1850),
                                       .pm_tmr = Gas_value(1, 32, 0x1808),
                                       .gpe0_sts = Gas_value(1, 128, 0x1880),
                                       .gpe0_ena = Gas_value(1, 128, 0x1890),
                                       .gpe1_sts = Gas_value(),
                                       .gpe1_ena = Gas_value()};

// The values of the registers encoded into the Tuxedo FADT.
inline const Gas_values tuxedo_gas_values{.pm1a_sts = Gas_value(1, 16, 0x1800),
                                          .pm1a_ena = Gas_value(1, 16, 0x1802),
                                          .pm1b_sts = Gas_value(),
                                          .pm1b_ena = Gas_value(),
                                          .pm1a_cnt = Gas_value(1, 16, 0x1804),
                                          .pm1b_cnt = Gas_value(),
                                          .pm2_cnt = Gas_value(1, 8, 0x1850),
                                          .pm_tmr = Gas_value(1, 32, 0x1808),
                                          .gpe0_sts = Gas_value(1, 128, 0x1860),
                                          .gpe0_ena = Gas_value(1, 128, 0x1870),
                                          .gpe1_sts = Gas_value(),
                                          .gpe1_ena = Gas_value()};

// The values of the registers encoded into Qemu's FADT
inline const Gas_values qemu_gas_values{.pm1a_sts = Gas_value(1, 16, 0x600),
                                        .pm1a_ena = Gas_value(1, 16, 0x602),
                                        .pm1b_sts = Gas_value(),
                                        .pm1b_ena = Gas_value(),
                                        .pm1a_cnt = Gas_value(1, 16, 0x604),
                                        .pm1b_cnt = Gas_value(),
                                        .pm2_cnt = Gas_value(),
                                        .pm_tmr = Gas_value(1, 32, 0x608),
                                        .gpe0_sts = Gas_value(1, 16, 0xAFE0),
                                        .gpe0_ena = Gas_value(1, 16, 0xAFE2),
                                        .gpe1_sts = Gas_value(),
                                        .gpe1_ena = Gas_value()};

// FADT taken from a Dell XPS 13 9360. This FADT table has the legacy register addresses and the newer
// extended address blocks for the ACPI registers populated.
inline const std::array<uint8_t, 268> fadt_xps{
    0x46, 0x41, 0x43, 0x50, 0x0C, 0x01, 0x00, 0x00, 0x05, 0x81, 0x44, 0x45, 0x4C, 0x4C, 0x20, 0x20, 0x43,
    0x42, 0x58, 0x33, 0x20, 0x20, 0x20, 0x00, 0x09, 0x20, 0x07, 0x01, 0x41, 0x4D, 0x49, 0x20, 0x13, 0x00,
    0x01, 0x00, 0x80, 0x31, 0xC1, 0x7A, 0x40, 0xA2, 0x53, 0x7A, 0x01, 0x02, 0x09, 0x00, 0xB2, 0x00, 0x00,
    0x00, 0xD1, 0xD2, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x18, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x50, 0x18, 0x00, 0x00, 0x08, 0x18, 0x00, 0x00, 0x80, 0x18, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x04, 0x02, 0x01, 0x04, 0x20, 0x00, 0x10, 0x00, 0x65, 0x00, 0x39, 0x00, 0x00, 0x04,
    0x10, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x32, 0x12, 0x00, 0x00, 0xA5, 0x84, 0x23, 0x00, 0x01, 0x08, 0x00,
    0x01, 0xB2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x40, 0xA2, 0x53, 0x7A, 0x00, 0x00, 0x00, 0x00, 0x01, 0x20, 0x00, 0x02, 0x00,
    0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x01, 0x10, 0x00, 0x02, 0x04, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
    0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x08, 0x00, 0x01, 0x50, 0x18, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x01, 0x20, 0x00, 0x03, 0x08, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
    0x80, 0x00, 0x01, 0x80, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x08, 0x00, 0x03, 0x04, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x01, 0x08, 0x00, 0x03, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

// FADT taken from a Tuxedo Book XP14 Gen12. The Tuxedo Laptop doesn't populate the legacy register addresses,
// thus the parser has to use the extended address blocks to parse the ACPI register addresses and sizes
inline const std::array<uint8_t, 268> fadt_tuxedo{
    0x46, 0x41, 0x43, 0x50, 0x0C, 0x01, 0x00, 0x00, 0x06, 0x20, 0x49, 0x4E, 0x53, 0x59, 0x44, 0x45, 0x54,
    0x47, 0x4C, 0x2D, 0x55, 0x4C, 0x54, 0x00, 0x02, 0x00, 0x00, 0x00, 0x41, 0x43, 0x50, 0x49, 0x00, 0x00,
    0x04, 0x00, 0x00, 0x10, 0xAA, 0x43, 0x00, 0x90, 0xBA, 0x43, 0x00, 0x02, 0x09, 0x00, 0xB2, 0x00, 0x00,
    0x00, 0xA0, 0xA1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x18, 0x00, 0x00, 0x60, 0x18, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x04, 0x02, 0x01, 0x04, 0x20, 0x00, 0x10, 0x00, 0x65, 0x00, 0xE9, 0x03, 0x00, 0x00,
    0x00, 0x00, 0x01, 0x03, 0x0D, 0x00, 0x32, 0x03, 0x00, 0x00, 0xB5, 0xC4, 0x20, 0x00, 0x01, 0x08, 0x00,
    0x01, 0xB2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFB, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0xBA, 0x43, 0x00, 0x00, 0x00, 0x00, 0x01, 0x20, 0x00, 0x02, 0x00,
    0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x01, 0x10, 0x00, 0x02, 0x04, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x08, 0x00, 0x01, 0x50, 0x18, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x01, 0x20, 0x00, 0x03, 0x08, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
    0x00, 0x00, 0x01, 0x60, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x08, 0x00, 0x03, 0x04, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x01, 0x08, 0x00, 0x03, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

// FADT used by qemu. This is a old FADT where the extended address blocks don't exist. Thus, the FADT parsing
// has to take the length of the FADT table into account.
inline const std::array<uint8_t, 116> fadt_qemu{
    0x46, 0x41, 0x43, 0x50, 0x74, 0x00, 0x00, 0x00, 0x01, 0x81, 0x42, 0x4F, 0x43, 0x48, 0x53, 0x20, 0x42,
    0x58, 0x50, 0x43, 0x20, 0x20, 0x20, 0x20, 0x01, 0x00, 0x00, 0x00, 0x42, 0x58, 0x50, 0x43, 0x01, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xFE, 0xBF, 0x40, 0x00, 0xFE, 0xBF, 0x01, 0x00, 0x09, 0x00, 0xB2, 0x00, 0x00,
    0x00, 0xF1, 0xF0, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x06, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x06, 0x00, 0x00, 0xE0, 0xAF, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x04, 0x02, 0x00, 0x04, 0x04, 0x00, 0x00, 0x00, 0xFF, 0x0F, 0xFF, 0x0F, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0xA5, 0x80, 0x00, 0x00};
